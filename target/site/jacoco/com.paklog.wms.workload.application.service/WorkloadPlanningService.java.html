<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WorkloadPlanningService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">workload-planning-service</a> &gt; <a href="index.source.html" class="el_package">com.paklog.wms.workload.application.service</a> &gt; <span class="el_source">WorkloadPlanningService.java</span></div><h1>WorkloadPlanningService.java</h1><pre class="source lang-java linenums">package com.paklog.wms.workload.application.service;

import com.paklog.wms.workload.adapter.event.WorkloadPlanningEventPublisher;
import com.paklog.wms.workload.domain.aggregate.DemandForecast;
import com.paklog.wms.workload.domain.aggregate.WorkloadPlan;
import com.paklog.wms.workload.domain.entity.WorkerCapacity;
import com.paklog.wms.workload.domain.repository.DemandForecastRepository;
import com.paklog.wms.workload.domain.repository.WorkloadPlanRepository;
import com.paklog.wms.workload.domain.valueobject.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Workload Planning Service
 * Core service for demand forecasting, labor capacity planning, and workload optimization
 */
@Service
@Transactional
public class WorkloadPlanningService {

<span class="fc" id="L27">    private static final Logger logger = LoggerFactory.getLogger(WorkloadPlanningService.class);</span>

    private final DemandForecastRepository forecastRepository;
    private final WorkloadPlanRepository planRepository;
    private final WorkloadPlanningEventPublisher eventPublisher;

    public WorkloadPlanningService(
            DemandForecastRepository forecastRepository,
            WorkloadPlanRepository planRepository,
            WorkloadPlanningEventPublisher eventPublisher
<span class="fc" id="L37">    ) {</span>
<span class="fc" id="L38">        this.forecastRepository = forecastRepository;</span>
<span class="fc" id="L39">        this.planRepository = planRepository;</span>
<span class="fc" id="L40">        this.eventPublisher = eventPublisher;</span>
<span class="fc" id="L41">    }</span>

    /**
     * Generate demand forecast using historical data
     */
    public DemandForecast generateDemandForecast(
            String warehouseId,
            ForecastPeriod period,
            LocalDateTime forecastDate,
            Map&lt;WorkloadCategory, List&lt;Integer&gt;&gt; historicalData
    ) {
<span class="fc" id="L52">        logger.info(&quot;Generating {} forecast for warehouse {} on {}&quot;,</span>
            period, warehouseId, forecastDate);

<span class="fc" id="L55">        String forecastId = UUID.randomUUID().toString();</span>
<span class="fc" id="L56">        DemandForecast forecast = DemandForecast.create(</span>
            forecastId, warehouseId, period, forecastDate
        );

        // Apply forecasting algorithm based on period
<span class="pc bpc" id="L61" title="4 of 5 branches missed.">        String model = switch (period) {</span>
<span class="nc" id="L62">            case HOURLY -&gt; &quot;EXPONENTIAL_SMOOTHING&quot;;</span>
<span class="fc" id="L63">            case DAILY -&gt; &quot;MOVING_AVERAGE&quot;;</span>
<span class="nc" id="L64">            case WEEKLY -&gt; &quot;WEIGHTED_MOVING_AVERAGE&quot;;</span>
<span class="pc" id="L65">            case MONTHLY -&gt; &quot;SEASONAL_DECOMPOSITION&quot;;</span>
        };

<span class="fc" id="L68">        forecast.setForecastingModel(model, Map.of(</span>
<span class="fc" id="L69">            &quot;alpha&quot;, 0.3,</span>
<span class="fc" id="L70">            &quot;window_size&quot;, 7,</span>
<span class="fc" id="L71">            &quot;seasonality&quot;, 7</span>
        ));

        // Generate forecast data points for each category
<span class="fc bfc" id="L75" title="All 2 branches covered.">        for (Map.Entry&lt;WorkloadCategory, List&lt;Integer&gt;&gt; entry : historicalData.entrySet()) {</span>
<span class="fc" id="L76">            WorkloadCategory category = entry.getKey();</span>
<span class="fc" id="L77">            List&lt;Integer&gt; historical = entry.getValue();</span>

            // Generate forecasts for the period
<span class="fc bfc" id="L80" title="All 2 branches covered.">            for (int i = 0; i &lt; period.getPeriodsAhead(); i++) {</span>
<span class="fc" id="L81">                LocalDateTime timestamp = forecastDate.plusHours(i * period.getHoursPerPeriod());</span>

                // Simple moving average forecast
<span class="fc" id="L84">                int forecastedVolume = calculateMovingAverage(historical, 7);</span>
<span class="fc" id="L85">                double confidenceInterval = calculateConfidenceInterval(historical);</span>

<span class="fc" id="L87">                forecast.addDataPoint(timestamp, category, forecastedVolume, confidenceInterval);</span>
            }
<span class="fc" id="L89">        }</span>

        // Calculate and update accuracy metrics
<span class="fc" id="L92">        double accuracy = 90.0; // Simulated accuracy</span>
<span class="fc" id="L93">        double mae = 5.0;</span>
<span class="fc" id="L94">        double mse = 25.0;</span>
<span class="fc" id="L95">        forecast.updateAccuracyMetrics(accuracy, mae, mse);</span>

<span class="fc" id="L97">        forecast = forecastRepository.save(forecast);</span>

        // Publish event
<span class="fc" id="L100">        eventPublisher.publishForecastGenerated(</span>
<span class="fc" id="L101">            forecastId, warehouseId, period.name(), model, accuracy</span>
        );

<span class="fc" id="L104">        return forecast;</span>
    }

    /**
     * Get forecast by ID
     */
    @Transactional(readOnly = true)
    public Optional&lt;DemandForecast&gt; getForecast(String forecastId) {
<span class="nc" id="L112">        return forecastRepository.findById(forecastId);</span>
    }

    /**
     * Get forecasts by warehouse
     */
    @Transactional(readOnly = true)
    public List&lt;DemandForecast&gt; getForecastsByWarehouse(String warehouseId) {
<span class="nc" id="L120">        return forecastRepository.findByWarehouseIdOrderByForecastDateDesc(warehouseId);</span>
    }

    /**
     * Create workload plan from demand forecast
     */
    public WorkloadPlan createWorkloadPlan(
            String warehouseId,
            LocalDate planDate,
            DemandForecast forecast
    ) {
<span class="nc" id="L131">        logger.info(&quot;Creating workload plan for warehouse {} on {}&quot;, warehouseId, planDate);</span>

<span class="nc" id="L133">        String planId = UUID.randomUUID().toString();</span>
<span class="nc" id="L134">        WorkloadPlan plan = WorkloadPlan.create(planId, warehouseId, planDate);</span>

        // Set planned volumes from forecast
<span class="nc bnc" id="L137" title="All 2 branches missed.">        for (WorkloadCategory category : WorkloadCategory.values()) {</span>
<span class="nc" id="L138">            int totalVolume = forecast.getTotalForecastedVolume(category);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (totalVolume &gt; 0) {</span>
<span class="nc" id="L140">                plan.setPlannedVolume(category, totalVolume);</span>
            }
        }

<span class="nc" id="L144">        return planRepository.save(plan);</span>
    }

    /**
     * Create workload plan with planned volumes
     */
    public WorkloadPlan createWorkloadPlan(
            String warehouseId,
            LocalDate planDate,
            Map&lt;WorkloadCategory, Integer&gt; plannedVolumes,
            String description
    ) {
<span class="fc" id="L156">        logger.info(&quot;Creating workload plan for warehouse {} on {}&quot;, warehouseId, planDate);</span>

<span class="fc" id="L158">        String planId = UUID.randomUUID().toString();</span>
<span class="fc" id="L159">        WorkloadPlan plan = WorkloadPlan.create(planId, warehouseId, planDate);</span>

        // Note: description is not currently supported in the domain model
        // If needed, would require adding a setNotes() method or similar

        // Set planned volumes
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (Map.Entry&lt;WorkloadCategory, Integer&gt; entry : plannedVolumes.entrySet()) {</span>
<span class="fc" id="L166">            plan.setPlannedVolume(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L167">        }</span>

<span class="fc" id="L169">        plan = planRepository.save(plan);</span>

        // Publish event
<span class="fc" id="L172">        eventPublisher.publishPlanCreated(</span>
<span class="fc" id="L173">            planId, warehouseId, planDate.toString(), plan.getTotalRequiredLaborHours()</span>
        );

<span class="fc" id="L176">        return plan;</span>
    }

    /**
     * Get workload plan by ID
     */
    @Transactional(readOnly = true)
    public Optional&lt;WorkloadPlan&gt; getWorkloadPlan(String planId) {
<span class="nc" id="L184">        return planRepository.findById(planId);</span>
    }

    /**
     * Get workload plans by warehouse
     */
    @Transactional(readOnly = true)
    public List&lt;WorkloadPlan&gt; getWorkloadPlansByWarehouse(String warehouseId) {
<span class="nc" id="L192">        return planRepository.findByWarehouseIdOrderByPlanDateDesc(warehouseId);</span>
    }

    /**
     * Assign worker to shift in plan
     */
    public WorkloadPlan assignWorkerToShift(
            String planId,
            ShiftType shiftType,
            String workerId,
            String workerName,
            WorkloadCategory primaryCategory,
            Integer plannedHours
    ) {
<span class="fc" id="L206">        logger.info(&quot;Assigning worker {} to {} shift for plan {}&quot;, workerId, shiftType, planId);</span>

<span class="fc" id="L208">        WorkloadPlan plan = getPlanOrThrow(planId);</span>
<span class="fc" id="L209">        plan.assignWorkerToShift(shiftType, workerId, workerName, primaryCategory, plannedHours);</span>

<span class="fc" id="L211">        plan = planRepository.save(plan);</span>

        // Publish event
<span class="fc" id="L214">        eventPublisher.publishWorkerAssigned(</span>
<span class="fc" id="L215">            planId, workerId, workerName, shiftType.name(), primaryCategory.name(), plannedHours</span>
        );

<span class="fc" id="L218">        return plan;</span>
    }

    /**
     * Optimize labor allocation for workload plan
     */
    public WorkloadPlan optimizeLaborAllocation(
            String planId,
            List&lt;WorkerCapacity&gt; availableWorkers
    ) {
<span class="fc" id="L228">        logger.info(&quot;Optimizing labor allocation for plan {}&quot;, planId);</span>

<span class="fc" id="L230">        WorkloadPlan plan = getPlanOrThrow(planId);</span>

        // Clear existing assignments
        // (In production, this would be more sophisticated)

        // Calculate required workers per category
<span class="fc" id="L236">        Map&lt;WorkloadCategory, Integer&gt; requiredWorkers = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        for (Map.Entry&lt;WorkloadCategory, Integer&gt; entry : plan.getPlannedVolumes().entrySet()) {</span>
<span class="fc" id="L238">            WorkloadCategory category = entry.getKey();</span>
<span class="fc" id="L239">            int volume = entry.getValue();</span>
<span class="fc" id="L240">            int required = category.calculateRequiredWorkers(volume, 8); // 8-hour shift</span>
<span class="fc" id="L241">            requiredWorkers.put(category, required);</span>
<span class="fc" id="L242">        }</span>

        // Assign workers to shifts using greedy algorithm
<span class="fc" id="L245">        List&lt;WorkerCapacity&gt; sortedWorkers = new ArrayList&lt;&gt;(availableWorkers);</span>
<span class="fc" id="L246">        sortedWorkers.sort((w1, w2) -&gt; w2.getSkillLevel().compareTo(w1.getSkillLevel()));</span>

<span class="fc bfc" id="L248" title="All 2 branches covered.">        for (WorkerCapacity worker : sortedWorkers) {</span>
            // Find best category for this worker
<span class="fc" id="L250">            WorkloadCategory bestCategory = findBestCategory(worker, requiredWorkers);</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            if (bestCategory != null) {</span>
                // Assign to appropriate shift
<span class="fc" id="L254">                ShiftType shift = determineOptimalShift(plan, bestCategory);</span>
<span class="fc" id="L255">                plan.assignWorkerToShift(shift, worker.getWorkerId(), worker.getName(),</span>
                    bestCategory, 8);

                // Decrease required count
<span class="fc" id="L259">                requiredWorkers.merge(bestCategory, -1, Integer::sum);</span>
            }
<span class="fc" id="L261">        }</span>

<span class="fc" id="L263">        return planRepository.save(plan);</span>
    }

    /**
     * Approve workload plan
     */
    public WorkloadPlan approvePlan(String planId) {
<span class="nc" id="L270">        logger.info(&quot;Approving workload plan {}&quot;, planId);</span>
<span class="nc" id="L271">        WorkloadPlan plan = getPlanOrThrow(planId);</span>
<span class="nc" id="L272">        plan.approve();</span>
<span class="nc" id="L273">        return planRepository.save(plan);</span>
    }

    /**
     * Approve workload plan with approver
     */
    public WorkloadPlan approvePlan(String planId, String approvedBy) {
<span class="fc" id="L280">        logger.info(&quot;Approving workload plan {} by {}&quot;, planId, approvedBy);</span>
<span class="fc" id="L281">        WorkloadPlan plan = getPlanOrThrow(planId);</span>
<span class="fc" id="L282">        plan.approve();</span>
<span class="fc" id="L283">        plan = planRepository.save(plan);</span>

        // Publish event
<span class="fc" id="L286">        eventPublisher.publishPlanApproved(</span>
            planId,
<span class="fc" id="L288">            plan.getWarehouseId(),</span>
            approvedBy,
<span class="fc" id="L290">            plan.getTotalWorkersAssigned(),</span>
<span class="fc" id="L291">            plan.getUtilizationPercentage()</span>
        );

<span class="fc" id="L294">        return plan;</span>
    }

    /**
     * Publish workload plan
     */
    public WorkloadPlan publishPlan(String planId) {
<span class="fc" id="L301">        logger.info(&quot;Publishing workload plan {}&quot;, planId);</span>
<span class="fc" id="L302">        WorkloadPlan plan = getPlanOrThrow(planId);</span>
<span class="fc" id="L303">        plan.publish();</span>
<span class="fc" id="L304">        plan = planRepository.save(plan);</span>

        // Publish event
<span class="fc" id="L307">        eventPublisher.publishPlanPublished(</span>
            planId,
<span class="fc" id="L309">            plan.getWarehouseId(),</span>
<span class="fc" id="L310">            plan.getPlanDate().toString(),</span>
<span class="fc" id="L311">            plan.getTotalWorkersAssigned()</span>
        );

<span class="fc" id="L314">        return plan;</span>
    }

    /**
     * Cancel workload plan
     */
    public WorkloadPlan cancelPlan(String planId, String reason) {
<span class="fc" id="L321">        logger.info(&quot;Cancelling workload plan {}: {}&quot;, planId, reason);</span>
<span class="fc" id="L322">        WorkloadPlan plan = getPlanOrThrow(planId);</span>
<span class="fc" id="L323">        plan.cancel(reason);</span>
<span class="fc" id="L324">        plan = planRepository.save(plan);</span>

        // Publish event
<span class="fc" id="L327">        eventPublisher.publishPlanCancelled(</span>
<span class="fc" id="L328">            planId, plan.getWarehouseId(), reason</span>
        );

<span class="fc" id="L331">        return plan;</span>
    }

    /**
     * Get workload plan recommendations
     */
    public WorkloadRecommendations getRecommendations(String warehouseId, LocalDate date) {
<span class="fc" id="L338">        DemandForecast forecast = forecastRepository</span>
<span class="fc" id="L339">            .findByWarehouseIdOrderByForecastDateDesc(warehouseId)</span>
<span class="fc" id="L340">            .stream()</span>
<span class="fc" id="L341">            .findFirst()</span>
<span class="fc" id="L342">            .orElse(null);</span>

<span class="fc" id="L344">        WorkloadPlan plan = planRepository</span>
<span class="fc" id="L345">            .findByWarehouseIdAndPlanDate(warehouseId, date)</span>
<span class="fc" id="L346">            .orElse(null);</span>

<span class="fc" id="L348">        List&lt;String&gt; recommendations = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (plan != null) {</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">            if (plan.isUnderstaffed()) {</span>
<span class="fc" id="L352">                recommendations.add(String.format(</span>
                    &quot;UNDERSTAFFED: Utilization at %.1f%%. Consider adding %d workers.&quot;,
<span class="fc" id="L354">                    plan.getUtilizationPercentage(),</span>
<span class="fc" id="L355">                    calculateAdditionalWorkersNeeded(plan)</span>
                ));
            }

<span class="pc bpc" id="L359" title="1 of 2 branches missed.">            if (plan.isOverstaffed()) {</span>
<span class="nc" id="L360">                recommendations.add(String.format(</span>
                    &quot;OVERSTAFFED: Utilization at %.1f%%. Consider reducing by %d workers.&quot;,
<span class="nc" id="L362">                    plan.getUtilizationPercentage(),</span>
<span class="nc" id="L363">                    calculateExcessWorkers(plan)</span>
                ));
            }

<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (plan.isBalanced()) {</span>
<span class="nc" id="L368">                recommendations.add(String.format(</span>
                    &quot;OPTIMAL: Utilization at %.1f%%. Plan is well-balanced.&quot;,
<span class="nc" id="L370">                    plan.getUtilizationPercentage()</span>
                ));
            }
        }

<span class="pc bpc" id="L375" title="3 of 4 branches missed.">        if (forecast != null &amp;&amp; !forecast.isAccurate()) {</span>
<span class="nc" id="L376">            recommendations.add(String.format(</span>
                &quot;LOW FORECAST ACCURACY: Current accuracy %.1f%%. Recommend model refinement.&quot;,
<span class="nc" id="L378">                forecast.getAccuracy()</span>
            ));
        }

<span class="fc" id="L382">        return new WorkloadRecommendations(recommendations, forecast, plan);</span>
    }

    // Helper methods

    private int calculateMovingAverage(List&lt;Integer&gt; data, int window) {
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        if (data.isEmpty()) {</span>
<span class="nc" id="L389">            return 0;</span>
        }

<span class="fc" id="L392">        int startIndex = Math.max(0, data.size() - window);</span>
<span class="fc" id="L393">        List&lt;Integer&gt; subset = data.subList(startIndex, data.size());</span>
<span class="fc" id="L394">        return (int) subset.stream().mapToInt(Integer::intValue).average().orElse(0);</span>
    }

    private double calculateConfidenceInterval(List&lt;Integer&gt; data) {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (data.size() &lt; 2) {</span>
<span class="nc" id="L399">            return 0.0;</span>
        }

<span class="fc" id="L402">        double mean = data.stream().mapToInt(Integer::intValue).average().orElse(0);</span>
<span class="fc" id="L403">        double variance = data.stream()</span>
<span class="fc" id="L404">            .mapToDouble(v -&gt; Math.pow(v - mean, 2))</span>
<span class="fc" id="L405">            .average()</span>
<span class="fc" id="L406">            .orElse(0);</span>

<span class="fc" id="L408">        return Math.sqrt(variance) * 1.96; // 95% confidence interval</span>
    }

    private WorkloadCategory findBestCategory(WorkerCapacity worker,
                                              Map&lt;WorkloadCategory, Integer&gt; required) {
<span class="fc" id="L413">        return required.entrySet().stream()</span>
<span class="pc bpc" id="L414" title="2 of 4 branches missed.">            .filter(e -&gt; e.getValue() &gt; 0 &amp;&amp; worker.canPerform(e.getKey()))</span>
<span class="fc" id="L415">            .max(Comparator.comparingInt(Map.Entry::getValue))</span>
<span class="fc" id="L416">            .map(Map.Entry::getKey)</span>
<span class="fc" id="L417">            .orElse(null);</span>
    }

    private ShiftType determineOptimalShift(WorkloadPlan plan, WorkloadCategory category) {
        // Simple logic: distribute across shifts
<span class="fc" id="L422">        int dayCount = plan.getShiftAssignments(ShiftType.DAY_SHIFT).size();</span>
<span class="fc" id="L423">        int eveningCount = plan.getShiftAssignments(ShiftType.EVENING_SHIFT).size();</span>
<span class="fc" id="L424">        int nightCount = plan.getShiftAssignments(ShiftType.NIGHT_SHIFT).size();</span>

<span class="fc bfc" id="L426" title="All 4 branches covered.">        if (dayCount &lt;= eveningCount &amp;&amp; dayCount &lt;= nightCount) {</span>
<span class="fc" id="L427">            return ShiftType.DAY_SHIFT;</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        } else if (eveningCount &lt;= nightCount) {</span>
<span class="fc" id="L429">            return ShiftType.EVENING_SHIFT;</span>
        } else {
<span class="fc" id="L431">            return ShiftType.NIGHT_SHIFT;</span>
        }
    }

    private int calculateAdditionalWorkersNeeded(WorkloadPlan plan) {
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (plan.getTotalAvailableLaborHours() == 0) {</span>
<span class="nc" id="L437">            return 0;</span>
        }

<span class="fc" id="L440">        int shortage = plan.getTotalRequiredLaborHours() - plan.getTotalAvailableLaborHours();</span>
<span class="fc" id="L441">        return Math.max(0, (int) Math.ceil(shortage / 8.0)); // 8-hour shifts</span>
    }

    private int calculateExcessWorkers(WorkloadPlan plan) {
<span class="nc bnc" id="L445" title="All 2 branches missed.">        if (plan.getTotalRequiredLaborHours() == 0) {</span>
<span class="nc" id="L446">            return 0;</span>
        }

<span class="nc" id="L449">        int excess = plan.getTotalAvailableLaborHours() - plan.getTotalRequiredLaborHours();</span>
<span class="nc" id="L450">        return Math.max(0, (int) Math.floor(excess / 8.0)); // 8-hour shifts</span>
    }

    private WorkloadPlan getPlanOrThrow(String planId) {
<span class="fc" id="L454">        return planRepository.findById(planId)</span>
<span class="pc" id="L455">            .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Workload plan not found: &quot; + planId));</span>
    }

    /**
     * Workload recommendations result
     */
<span class="fc" id="L461">    public record WorkloadRecommendations(</span>
        List&lt;String&gt; recommendations,
        DemandForecast latestForecast,
        WorkloadPlan currentPlan
    ) {}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>